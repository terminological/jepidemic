---
title: "Cori method"
author: "Rob Challen"
date: '`r format(Sys.Date(), "%d-%m-%Y")`'
output: 
  pdf_document :
    fig_caption: yes
header-includes:
 \usepackage{float}
 \floatplacement{figure}{H}    

knit: (function(inputFile, encoding,...) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "~/Dropbox/covid19/serial-interval/", output_file=paste0('cori-method-',Sys.Date(),'.pdf')) })
fig_width: 7
fig_height: 5
out.width: "100%"
bibliography: jepidemic.bib
csl: jepidemic.csl
vignette: >
  %\VignetteIndexEntry{Cori method}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

---




```{r, include = TRUE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  error = TRUE
)
```



# Testing java implementation
```{r eval=FALSE}
try(detach("package:jepidemic", unload = TRUE),silent = TRUE)
remove.packages("jepidemic")
# rm(list = ls()) may be required to clear old versions of the library code
# Restarting R maybe also required if there was a running java VM otherwise changes to the jars on the classpath are not picked up.
# install locally compiled R library:
devtools::install("~/Git/jepidemic/r-library/", upgrade = "never")
```

```{r}

library(EpiEstim)
data(Flu2009)

ggplot(Flu2009$incidence,aes(x=dates,y=I))+geom_bar(stat="identity")

rtPlot = function(out, ylim=c(0,5)) {
  ggplot(out %>% filter(!is.nan(Rt.Mean)), aes(x=Rt.EndDate, y=Rt.Mean, colour=as.factor(Rt.Window)))+
    geom_point(size=1) +
    geom_errorbarh(aes(x=Rt.EndDate, xmin=Rt.StartDate, xmax=Rt.EndDate), alpha=0.3) +
    geom_errorbar(aes(y=Rt.Quantile.0.5, ymin = Rt.Quantile.0.025, ymax = Rt.Quantile.0.975), alpha=0.3)+
    facet_wrap(vars(as.factor(Rt.Window)))+guides(colour="none")+coord_cartesian(ylim=ylim)
}

rtPanel = function(out, ylim=c(0,5)) {
  ggplot(out %>% filter(!is.nan(Rt.Mean)), aes(x=Rt.EndDate, y=Rt.Mean, colour=as.factor(Rt.Window)))+
    geom_point(size=1) +
    geom_errorbarh(aes(x=Rt.EndDate, xmin=Rt.StartDate, xmax=Rt.EndDate), alpha=0.3) +
    geom_errorbar(aes(y=Rt.Quantile.0.5, ymin = Rt.Quantile.0.025, ymax = Rt.Quantile.0.975), alpha=0.3)+
    guides(colour="none")+coord_cartesian(ylim=ylim)
}
```

## Reference implementation

* Noise with smaller windows
* Particularly when smaller numbers at end of time series
* Windows > 4 lose some features when numbers larger in early part of time series
* No optimal.

```{r}
epiest = bind_rows(lapply(1:14, function(window) {
  tau = window-1
  tmp = EpiEstim::estimate_R(Flu2009$incidence, 
                             config = make_config(method = "non_parametric_si",
                                                  si_distr = Flu2009$si_distr, 
                                                  mean_prior=5, std_prior=5,
                                                  t_start=2:(32-tau),t_end=(2+tau):32))
  return(tmp$R %>% mutate(Rt.StartDate = tmp$date[t_start],
                          Rt.EndDate = tmp$date[t_end],
                          Rt.Mean = `Mean(R)`, 
                          Rt.Quantile.0.5 = `Median(R)`, 
                          Rt.Quantile.0.025 = `Quantile.0.025(R)`, 
                          Rt.Quantile.0.975 = `Quantile.0.975(R)`,
                          Rt.Window = window
  ))
}))

rtPlot(epiest)

```


```{r}
# Ensure equivalence
J = jepidemic::JavaApi$new()
estim = J$CoriEstimator$new(r0Mean = 5,r0SD = 5,maxWindow = 14)
estim$withInfectivityProfile(infectivityProfile = Flu2009$si_distr)
estim$detailedOutput()
estim$withDefaultPrior()
estim$atStartOfTimeseries()


jepidem = estim$estimateRtSingle(incidence = Flu2009$incidence,dateColName = "dates", incidenceColName = "I")

comp = epiest %>% filter(is.finite(Rt.Mean)) %>% select(Rt.StartDate,Rt.EndDate,Rt.Window,Rt.Mean) %>% #,Rt.Quantile.0.5,Rt.Quantile.0.025,Rt.Quantile.0.975) %>%
  inner_join(
    jepidem %>% filter(is.finite(Rt.Mean)) %>% select(Rt.StartDate,Rt.EndDate,Rt.Window,Rt.Mean), #,Rt.Quantile.0.5,Rt.Quantile.0.025,Rt.Quantile.0.975),
    by=c("Rt.StartDate","Rt.EndDate","Rt.Window"), suffix=c(".epiest",".jepidem")
)

mismatches = comp %>% mutate(matches = abs(Rt.Mean.epiest - Rt.Mean.jepidem)<0.000000000001) %>% filter(isFALSE(matches));

if (mismatches %>% nrow() != 0) {
  mismatches
  stop("mismatch between jepidemic and epiestim")
}
# rtPlot(out)

# https://raw.githubusercontent.com/epiforecasts/EpiNow2/master/inst/dev/figs/gp_nuts.png
# https://raw.githubusercontent.com/epiforecasts/EpiNow2/master/inst/dev/figs/backcalc_nuts.png
# https://github.com/epiforecasts/EpiNow2/blob/master/inst/dev/recover-synthetic.R
# https://github.com/epiforecasts/EpiSoon - simulation
# https://github.com/epiforecasts/scoringutils
```

```{r}
klGammaVsGamma = function(mean1, sd1, mean2, sd2) {
  if (sd1>mean1 | sd2>mean2) stop("sd must be smaller than mean")
  range = seq(0,10,length=200)
  g1 = dgamma(range, shape=mean1^2/sd1^2,rate = mean1/sd1^2)
  g2 = dgamma(range, shape=mean2^2/sd2^2,rate = mean2/sd2^2)
  kl = flexmix::KLdiv(cbind(g1=g1,g2=g2))[1,2]
  # A matrix of KL divergences where the rows correspond to using the respective distribution as  in the formula above.
  return(kl)
}

klGammaVsUnif = function(value1, precision1, mean2, sd2) {
  if (sd2>mean2) stop("sd must be smaller than mean")
  range = seq(0,10,length=200)
  g1 = dunif(range, min = value1-precision1,max = value1+precision1)
  g2 = dgamma(range, shape=mean2^2/sd2^2,rate = mean2/sd2^2)
  kl = flexmix::KLdiv(cbind(g1=g1,g2=g2))[1,2]
  # A matrix of KL divergences where the rows correspond to using the respective distribution as  in the formula above.
  return(kl)
}


klGammaVsGamma(mean1=2,sd1=1.5,mean2=2.3,sd2=2.1)
klGammaVsUnif(value1=2,precision1=0.0001,mean2=2,sd2=0.002)

```

```{r}

estim$withAdaptivePrior(factor = 1.3)
out2 = estim$estimateRtSingle(incidence = Flu2009$incidence,dateColName = "dates", incidenceColName = "I")
rtPlot(out2)
```


```{r}

estim$withFixedPrior(mean = 1,sd = 5)
out3 = estim$estimateRtSingle(incidence = Flu2009$incidence,dateColName = "dates", incidenceColName = "I")
rtPlot(out3)
```

```{r}

#install.packages("projections")


Rt = tibble::tibble(
  date = as.Date(as.Date("2020-01-01"):(as.Date("2020-01-01")+99),"1970-01-01"),
  time_change = 1:200
) %>% mutate(
  R = case_when(
    time_change <= 20 ~ 1,
    time_change <= 40 ~ 1.1,
    time_change <= 60 ~ 0.6,
    time_change <= 80 ~ 1,
    TRUE ~ 1.5,
    )
)

seed = incidence::incidence(dates = as.Date(unlist(lapply(as.Date("2019-12-15"):as.Date("2019-12-31"),function(x) rep(x,runif(1,95,105)))),"1970-01-01"))
proj_3 <- projections::project(x = seed, R = c(Rt$R,1), n_sim=1,si = Flu2009$si_distr, n_days = 200, time_change = Rt$time_change)
plot(proj_3)
tmp = seedDf %>% bind_rows(as.data.frame(proj_3,long=TRUE) %>% group_by(date) %>% summarise(incidence = mean(incidence)))
Rt = Rt %>% inner_join(tmp, by="date")
```

```{r}
estim$withDefaultPrior()
out4 = estim$estimateRt(Rt,dateColName = "date",incidenceColName = "incidence")
out4a = out4 %>% group_by(profileId,date,window,startDate,endDate) %>% summarise(across(c(incidence,starts_with("Rt")), ~mean(.x,na.rm = TRUE)))
rtPlot(out4a,ylim=c(0.5,2))+geom_line(data=Rt,aes(x=date,y=R),colour="black",alpha=0.5)
```


```{r}
J = jepidemic::JavaApi$new()
estim2 = J$CoriEstimator$new(r0Mean = 1,r0SD = 5,maxWindow = 14)
estim2$withInfectivityProfile(infectivityProfile = Flu2009$si_distr)
estim2$inMiddleOfTimeseries()
estim2$withAdaptivePrior(1.25)
estim2$selectAdaptiveWindow(incidenceSum = 200,minWindow = 3)
estim2$collectMixtureQuantiles()

out5 = estim2$estimateRt(tmp,dateColName = "date",incidenceColName = "incidence")
out6 = out5 %>% group_by(window,startDate,endDate) %>% summarise(across(c(incidence,starts_with("Rt")), ~mean(.x,na.rm = TRUE)))
rtPanel(out6,ylim=c(0.5,2))+geom_line(data=Rt,aes(x=date,y=R),colour="black",alpha=0.5)

```