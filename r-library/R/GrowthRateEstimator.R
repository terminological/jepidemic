# Generated by r6-generator-maven-plugin: do not edit by hand
# Contact: rc538@exeter.ac.uk
# Java Epidemic
#' R6 Bindings for Java GrowthRateEstimator
#'
#' @description
#' An estimator of the reproduction number (\(R_t\)) using a renewal equation method. 
#' 
#' This is a class of the jepidemic generated R library.
#' 
#' Version: 0.03
#' 
#' Generated: 2022-05-24T22:12:30.967976
#'
#' @details
	#' The renewal equation method depends on a time series of infections, and on the infectivity profile - 
	#' a measure of the probability that a secondary infection occurred on a specific day after the primary case, 
	#' given a secondary infection occurred. A Bayesian framework is then used to update a prior probabilistic 
	#' estimate of \(R_t\) on any given day with both information gained from the time series of infections in the 
	#' epidemic to date and the infectivity profile to produce a posterior estimate of \(R_t\). This is based on the 
	#' article:<br>
	#' 
	#' <br>A. GrowthRate, N. M. Ferguson, C. Fraser, and S. Cauchemez, ‘A New Framework and Software to Estimate Time-Varying Reproduction Numbers During Epidemics’, Am J Epidemiol, vol. 178, no. 9, pp. 1505–1512, Nov. 2013, doi: 10.1093/aje/kwt133.<br>
	#' 
	#' <br> and the implementation of it in the R Library EpiEstim. It assumes that infections (or other type of observation) are a 
	#' Poisson distributed process and that the reproduction number is a gamma distributed quantity. The estimates of \(R_t\) may be 
	#' aggregated over a specific "window" to provide a more stable estimate.
#' @export
GrowthRateEstimator = R6::R6Class("GrowthRateEstimator", public=list(

	#' @field .api internal pointer to the library object.
	.api = NULL,

	#' @field .jobj internal pointer to the rJava reference to the java object.
	.jobj = NULL,


	#' @description
	#' Create a new GrowthRateEstimator this is not for general use and instances should be created through the
	#' package api class. See example.
	#' @param jobj The internal rJava reference.
	#' @param api The R6 api library class.
	#' @return A new GrowthRateEstimator object.
	#' @examples
	#' J = jepidemic::JavaApi$get();
	#' instance = J$GrowthRateEstimator$new(minWindow, maxWindow)
	initialize = function(jobj,api){
		self$.jobj = jobj;
		self$.api = api;
	},
	
	#' @description 
	#' withOutputQuantiles: 
	#' Allows you to change the quantiles returned by the estimator. The defaults are c(0.025,0.05,0.25,0.5,0.75,0.95,0.975)
	#' @param quantiles the desired quantiles of the output - (java expects a RNumericVector)
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	withOutputQuantiles = function(quantiles) {
		# copy parameters
		tmp_quantiles = self$.api$.toJava$RNumericVector(quantiles);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="withOutputQuantiles" , tmp_quantiles, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' withSaneDefaults: 
	#' Provides a sensible baseline configuration for the estimator that involves estimating the poisson rate using the 
	#' previous timestep's posterior and growth rate estimates. Multiple posterior
	#' estimates are combined using a weighted average based on a discretised normal distributed weight with mean of 7 and SD of 4.
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	withSaneDefaults = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="withSaneDefaults" , check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' withInitialIncidence: 
	#' Allows configuration of the initial incidence. If this is omitted the initial incidence is guessed from the first entry in the timeseries
	#' @param incidence - the prior incidence estimate prior to the the beginning of the time series. - (java expects a double)
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	withInitialIncidence = function(incidence) {
		# copy parameters
		tmp_incidence = self$.api$.toJava$double(incidence);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="withInitialIncidence" , tmp_incidence, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' withGaussianEstimateWeighting: 
	#' Allows configuration of the weighting of estimate combination for the weighted mixture combination. 
	#' This uses a discretised normal distribution to generate values for the weighting. The weighting is 
	#' applied to each supported estimate determined by the data window of that estimate.  The default value
	#' is a mean of 7 and SD of 4
	#' @param meanTau the mean of the normal distribution of weights - (java expects a double)
	#' @param sdTau the sd of the normal distribution of weights - (java expects a double)
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	withGaussianEstimateWeighting = function(meanTau, sdTau) {
		# copy parameters
		tmp_meanTau = self$.api$.toJava$double(meanTau);
		tmp_sdTau = self$.api$.toJava$double(sdTau);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="withGaussianEstimateWeighting" , tmp_meanTau, tmp_sdTau, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' withEstimateWeighting: 
	#' Allows configuration of the weighting of estimate combination for the weighted mixture combination. 
	#' This assumes the weights are given as a vector where the first entry is the weight for an estimate using a 
	#' data window of 1. The vector should be the same length as the maxWindow parameter used in configuring the 
	#' GrowthRateEstimator or 14 if the defaults were used.
	#' @param weights - a vector of weights for each data window - (java expects a RNumericVector)
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	withEstimateWeighting = function(weights) {
		# copy parameters
		tmp_weights = self$.api$.toJava$RNumericVector(weights);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="withEstimateWeighting" , tmp_weights, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' combineEstimatesWithWeightedMixture: 
	#' Sets the estimator to use a weighted mixture to combine estimates based on the length of different data windows, using weights defined 
	#' by withEstimateWeighting() or withGaussianEstimateWeighting(). If none is set the weighting defaults to a discretised normal
	#' distribution with mean of 7 an SD of 4.
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	combineEstimatesWithWeightedMixture = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="combineEstimatesWithWeightedMixture" , check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' priorIncidenceFromPreviousPosterior: 
	#' Select a prior estimate for the poisson rate by taking the previous posterior and multiplying 
	#' the SD by a constant factor
	#' @param multiplyingSDby - factor to multiply SD by. Must be greater than or equal to 1. - (java expects a double)
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	priorIncidenceFromPreviousPosterior = function(multiplyingSDby) {
		# copy parameters
		tmp_multiplyingSDby = self$.api$.toJava$double(multiplyingSDby);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="priorIncidenceFromPreviousPosterior" , tmp_multiplyingSDby, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' priorIncidenceFromScaledPreviousPosterior: 
	#' Select a prior estimate for the poisson rate by taking the previous posterior and multiplying 
	#' the SD by a factor determined by the difference between the t-1 and t-2 incidence. This allows for 
	#' rapid rate of change to be detected and less weight given to the prior in this situation
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	priorIncidenceFromScaledPreviousPosterior = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="priorIncidenceFromScaledPreviousPosterior" , check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' priorIncidenceFromPosteriorAndGrowthRate: 
	#' Select a prior estimate for the poisson rate by taking the previous posterior and increasing it by  
	#' the exponential previous posterior growth rate and multiplying the resulting disctribution by a 
	#' constant factor. This is a mechanistic prior.
	#' @param multiplyingSDby - factor to multiply SD by. Must be greater than or equal to 1. - (java expects a double)
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	priorIncidenceFromPosteriorAndGrowthRate = function(multiplyingSDby) {
		# copy parameters
		tmp_multiplyingSDby = self$.api$.toJava$double(multiplyingSDby);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="priorIncidenceFromPosteriorAndGrowthRate" , tmp_multiplyingSDby, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' priorIncidenceFromScaledPosteriorAndGrowthRate: 
	#' Select a prior estimate for the poisson rate by taking the previous posterior and increasing it by  
	#' the exponential previous posterior growth rate and multiplying the resulting disctribution by a 
	#' factor determined by the change in t-1 and t-2 indidence. This is a mechanistic prior.
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	priorIncidenceFromScaledPosteriorAndGrowthRate = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="priorIncidenceFromScaledPosteriorAndGrowthRate" , check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' priorIncidenceFromPosteriorMean: 
	#' Select a prior estimate for the poisson rate by taking the previous posterior and constructing a prior with 
	#' mean and sd both equal to the mean of the previous posterior.
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	priorIncidenceFromPosteriorMean = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="priorIncidenceFromPosteriorMean" , check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' priorIncidenceFromPosteriorMeanAndGrowthRate: 
	#' Select a prior estimate for the poisson rate by taking the previous posterior and constructing a prior with 
	#' mean and sd both equal to the mean of the previous posterior plus the growth rate.
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	priorIncidenceFromPosteriorMeanAndGrowthRate = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="priorIncidenceFromPosteriorMeanAndGrowthRate" , check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' priorIncidenceFromPosteriorMeanAndCoefVariation: 
	#' Select a prior estimate for the poisson rate by taking the previous posterior and constructing a prior with 
	#' mean and sd both equal to the mean of the previous posterior.
	#' @param kappa - the coefficient of variation of the prior. - (java expects a double)
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	priorIncidenceFromPosteriorMeanAndCoefVariation = function(kappa) {
		# copy parameters
		tmp_kappa = self$.api$.toJava$double(kappa);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="priorIncidenceFromPosteriorMeanAndCoefVariation" , tmp_kappa, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' priorIncidenceFromPosteriorMeanAndGrowthRateAndCoefVariation: 
	#' Select a prior estimate for the poisson rate by taking the previous posterior and constructing a prior with 
	#' mean and sd both equal to the mean of the previous posterior plus the growth rate.
	#' @param kappa - the coefficient of variation of the prior. - (java expects a double)
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	priorIncidenceFromPosteriorMeanAndGrowthRateAndCoefVariation = function(kappa) {
		# copy parameters
		tmp_kappa = self$.api$.toJava$double(kappa);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="priorIncidenceFromPosteriorMeanAndGrowthRateAndCoefVariation" , tmp_kappa, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' useAllPosteriorEstimates: 
	#' The posterior estimates for each combination of data window and infectivity profile are all retained and combined
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	useAllPosteriorEstimates = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="useAllPosteriorEstimates" , check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' usePosteriorEstimatesFromOneWindow: 
	#' The posterior estimates for only one data window, but all infectivity profiles, are retained and combined. N.b. the same effect
	#' can be achieved by setting the minWindow and maxWindow in the constructor.
	#' @param tau the window width to retain. - (java expects a int)
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	usePosteriorEstimatesFromOneWindow = function(tau) {
		# copy parameters
		tmp_tau = self$.api$.toJava$int(tau);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="usePosteriorEstimatesFromOneWindow" , tmp_tau, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' usePosteriorEstimatesWithEnoughData: 
	#' The posterior estimates for data windows that include a reasonable amount of data are retained and combined. This 
	#' suppresses noisy estimates made on a very few data points when incidence is low.
	#' @param sumIncidence - the minimum number of cases that must be observed in a data window before the estimate is ignored. - (java expects a int)
	#' @return R6 GrowthRateEstimator object: 
	#' a fluent method
	usePosteriorEstimatesWithEnoughData = function(sumIncidence) {
		# copy parameters
		tmp_sumIncidence = self$.api$.toJava$int(sumIncidence);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="usePosteriorEstimatesWithEnoughData" , tmp_sumIncidence, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' withInfectivityProfile: 
	#' Configure the estimator with an infectivity profile. At least one profile must be added for an estimate of R_t to be made
	#' @param infectivityProfile - A numeric vector of the daily discrete probability of a secondary infection event occurring given an infected individual. It is assumed that this vector starts 
	#' at time zero with a probability of zero. - (java expects a RNumericVector)
	#' @param replace -  replace the existing infectivity profile with this new one? if false then the profile is added to a list. - (java expects a boolean)
	#' @return R6 GrowthRateEstimator object: 
	#' The estimator itself (a fluent method)
	withInfectivityProfile = function(infectivityProfile, replace) {
		# copy parameters
		tmp_infectivityProfile = self$.api$.toJava$RNumericVector(infectivityProfile);
		tmp_replace = self$.api$.toJava$boolean(replace);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="withInfectivityProfile" , tmp_infectivityProfile, tmp_replace, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' withInfectivityProfileMatrix: 
	#' Configure the estimator with an infectivity profile by specifying it as a matrix. This will replace all previously set profiles.
	#' @param infectivityProfiles - A numeric array of the daily discrete probability of a secondary infection event occurring given an infected individual in each column. It is assumed that this vector starts 
	#' at time zero with a probability of zero. - (java expects a RNumericArray)
	#' @return R6 GrowthRateEstimator object: 
	#' The estimator itself (a fluent method)
	withInfectivityProfileMatrix = function(infectivityProfiles) {
		# copy parameters
		tmp_infectivityProfiles = self$.api$.toJava$RNumericArray(infectivityProfiles);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/growth/GrowthRateEstimator;", method="withInfectivityProfileMatrix" , tmp_infectivityProfiles, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = GrowthRateEstimator$new(
				self$.api$.fromJava$GrowthRateEstimator(tmp_out),
				self$.api
			);
			return(out);
		}
	},
	#' @description 
	#' estimateGrowthRate: 
	#' Estimates growth rate and, if configured with an infectivity profile, \(R_t\) for a one or more timeseries of infections in an epidemic. If the supplied dataframe is grouped it assumes ach grouping is a timeseries
	#' @param incidence - a dataframe containing at least 2 columns (one containing a date, the other a numeric count of cases). The dataframe may be grouped, in which case grouping is preserved, and each group is treated as a seperate time seriesincidenceColName - the name of the incidence column - (java expects a RDataframe)
	#' @param dateColName - the name of the date column - (java expects a String)
	#' @param incidenceColName - the name of the incidence column - (java expects a String)
	#' @return RDataframe: 
	#' a dataframe, containing a summary of the estimates of incidence, growth rate and \(R_t\) with mean, sd, and quantiles for each day.
	estimateGrowthRate = function(incidence, dateColName, incidenceColName) {
		# copy parameters
		tmp_incidence = self$.api$.toJava$RDataframe(incidence);
		tmp_dateColName = self$.api$.toJava$String(dateColName);
		tmp_incidenceColName = self$.api$.toJava$String(incidenceColName);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Luk/co/terminological/rjava/types/RDataframe;", method="estimateGrowthRate" , tmp_incidence, tmp_dateColName, tmp_incidenceColName, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# convert java object back to R
		out = self$.api$.fromJava$RDataframe(tmp_out);
		if(is.null(out)) return(invisible(out))
		return(out);
	},
	#' @description 
	#' estimateGrowthRateSingle: 
	#' Estimates \(R_t\) for a single timeseries of infections in an epidemic.
	#' @param incidence - a dataframe containing at least 2 columns (one containing a date, the other a numeric count of cases).incidenceColName - the name of the incidence column - (java expects a RDataframe)
	#' @param dateColName - the name of the date column - (java expects a String)
	#' @param incidenceColName - the name of the incidence column - (java expects a String)
	#' @return RDataframe: 
	#' a dataframe, containing either a summary of the estimates of \(R_t\) with mean, sd, and quantiles for each day, or a full breakdown of the component \(R_t\) estimates.
	estimateGrowthRateSingle = function(incidence, dateColName, incidenceColName) {
		# copy parameters
		tmp_incidence = self$.api$.toJava$RDataframe(incidence);
		tmp_dateColName = self$.api$.toJava$String(dateColName);
		tmp_incidenceColName = self$.api$.toJava$String(incidenceColName);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Luk/co/terminological/rjava/types/RDataframe;", method="estimateGrowthRateSingle" , tmp_incidence, tmp_dateColName, tmp_incidenceColName, check=FALSE);
		self$.api$printMessages()
		# check for exceptions and rethrow them
		.jcheck()
		# convert java object back to R
		out = self$.api$.fromJava$RDataframe(tmp_out);
		if(is.null(out)) return(invisible(out))
		return(out);
	},
	
	#' @description The output of toString() of this GrowthRateEstimator
	print = function() {
		tmp_out = .jcall(self$.jobj, returnSig = "Ljava/lang/String;", method="toString");
		self$.api$printMessages()
		print(tmp_out)
		invisible(self)
	},
	
	#' @description The output of equals() of this GrowthRateEstimator
	#' @param object The R6 instance to test for equality to this GrowthRateEstimator  
	equals = function(object) {
		if (is.null(object$.jobj)) return(FALSE)
		return(self$.jobj$equals(object$.jobj))
	},
	
	#' @description Allow this object to be garbage collected.
	finalize = function() {
		self$.jobj = .jnull("org/github/terminological/jepidemic/growth/GrowthRateEstimator")
		self$.jobj = NULL
		.jgc(R.gc = FALSE)
	}
))
