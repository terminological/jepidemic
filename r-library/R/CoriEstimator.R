# Generated by r6-generator-maven-plugin: do not edit by hand
# Contact: rc538@exeter.ac.uk
# Java Epidemic
#' R6 Bindings for Java CoriEstimator
#'
#' @description
#' An estimator of the reproduction number (\(R_t\)) using a renewal equation method. 
#' 
#' This is a class of the jepidemic generated R library.
#' 
#' Version: 0.03
#' 
#' Generated: 2022-01-28T16:04:19.701942
#'
#' @details
	#' #' The renewal equation method depends on a time series of infections, and on the infectivity profile - 
	#' a measure of the probability that a secondary infection occurred on a specific day after the primary case, 
	#' given a secondary infection occurred. A Bayesian framework is then used to update a prior probabilistic 
	#' estimate of \(R_t\) on any given day with both information gained from the time series of infections in the 
	#' epidemic to date and the infectivity profile to produce a posterior estimate of \(R_t\). This is based on the 
	#' article:<br>
	#' 
	#' <br>A. Cori, N. M. Ferguson, C. Fraser, and S. Cauchemez, ‘A New Framework and Software to Estimate Time-Varying Reproduction Numbers During Epidemics’, Am J Epidemiol, vol. 178, no. 9, pp. 1505–1512, Nov. 2013, doi: 10.1093/aje/kwt133.<br>
	#' 
	#' <br> and the implementation of it in the R Library EpiEstim. It assumes that infections (or other type of observation) are a 
	#' Poisson distributed process and that the reproduction number is a gamma distributed quantity. The estimates of \(R_t\) may be 
	#' aggregated over a specific "window" to provide a more stable estimate.
#' @export
CoriEstimator = R6::R6Class("CoriEstimator", public=list(

	#' @field .api internal pointer to the library object.
	.api = NULL,

	#' @field .jobj internal pointer to the rJava reference to the java object.
	.jobj = NULL,


	#' @description
	#' Create a new CoriEstimator this is not for general use and instances should be created through the
	#' package api class. See example.
	#' @param jobj The internal rJava reference.
	#' @param api The R6 api library class.
	#' @return A new CoriEstimator object.
	#' @examples
	#' J = jepidemic::JavaApi$get();
	#' instance = J$CoriEstimator$new(r0Mean, r0SD, maxWindow)
	initialize = function(jobj,api){
		self$.jobj = jobj;
		self$.api = api;
	},
	
	#' @description 
	#' legacySupport: 
	#' no description
	#' @param on - a boolean flag to switch on (TRUE) or off (FALSE) eipestim naming convention - (java expects a boolean)
	#' @return R6 CoriEstimator object: 
	#' the estimator itself (a fluent method)
	legacySupport = function(on) {
		# copy parameters
		tmp_on = self$.api$.toJava$boolean(on);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="legacySupport" , tmp_on); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' selectSpecificWindow: 
	#' The select methods define how the posterior estimate of \(R_t\) is selected. In this case a set value for the window is used. This must be less or equal to the 
	#' value of maxWindow supplied in the CoriEstimator::new constructor. The window defines how many data points prior to the time of the estimate are used to synthesise the posterior
	#' estimate of \(R_t\), and so tends to reduce the uncertainty around the value of \(R_t\), but longer values of window introduces temporal uncertainty into
	#' the estimates. This is as implemented in EpiEstim (with a default value of 7 for the window).
	#' @param window - a number of days - (java expects a int)
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	selectSpecificWindow = function(window) {
		# copy parameters
		tmp_window = self$.api$.toJava$int(window);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="selectSpecificWindow" , tmp_window); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' selectAdaptiveWindow: 
	#' The adaptive windowing strategy selects a posterior estimate of \(R_t\) by selecting the shortest window length (&gt; minWindow) which spans at least incidenceSum infection 
	#' (or observation) counts. This ensures that where numbers are low the estimation window is lengthened (up ot the value of maxWindow provided to the CoriEstimator::new constructor) to 
	#' include more data at the cost of temporal precision. This prevents stochastic noise from dominating the estimates of \(R_t\).
	#' @param incidenceSum - the number of cases that must be observed in a window. It there are fewer that this the window will be lengthened. Larger values lead to smoother estiamtes at the cost of reduced temporal precision. - (java expects a double)
	#' @param minWindow - the minimum size of the window that will be selected. In times of very high case numbers a minimum window prevents spurious outliers from completely dominating that days estimate of \(R_t\). - (java expects a int)
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	selectAdaptiveWindow = function(incidenceSum, minWindow) {
		# copy parameters
		tmp_incidenceSum = self$.api$.toJava$double(incidenceSum);
		tmp_minWindow = self$.api$.toJava$int(minWindow);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="selectAdaptiveWindow" , tmp_incidenceSum, tmp_minWindow); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' selectMinimumUncertainty: 
	#' The minimum uncertainty strategy aims to select a window for the posterior \(R_t\) estimate based on minimising a combined value for uncertainty. The uncertainty in this case is the 
	#' product of the (timeVsRt)th root of SD of the posterior estimate and the window size to the power of timeVsRt. <br><br>
	#' 
	#' $$window^{timeVsRt} * SD_{posterior}^\frac{1}{timeVsRt}$$
	#' @param timeVsRt - the relative importance parameter. Values above one favour temporal certainty; values under one favour \(R_t\) estimate certainty - (java expects a double)
	#' @param minWindow - the minimum size of the window that will be selected. - (java expects a int)
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	selectMinimumUncertainty = function(timeVsRt, minWindow) {
		# copy parameters
		tmp_timeVsRt = self$.api$.toJava$double(timeVsRt);
		tmp_minWindow = self$.api$.toJava$int(minWindow);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="selectMinimumUncertainty" , tmp_timeVsRt, tmp_minWindow); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' selectMixtureCombination: 
	#' The mixture combination strategy for selecting a posterior \(R_t\) involves finding all the estimates that have a window that is centred on the estimate date (this may involve longer windowed estimate from
	#' dates in the future) and estimating a gamma distribution with the same mean and SD as the mixture of all the estimates. This combined estimate involves estimates of all different windows.
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	selectMixtureCombination = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="selectMixtureCombination" ); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' selectWeightedMixtureCombination: 
	#' The mixture combination strategy for selecting a posterior \(R_t\) involves finding all the estimates that have a window that is centred on the estimate date (this may involve longer windowed estimate from
	#' dates in the future) and estimating a gamma distribution with the same mean and SD as the mixture of all the estimates. This combined estimate involves estimates of all different windows.
	#' @param weights - the weighting of the different windows as a vector which much be the same length as the longest window, maxTau. - (java expects a RNumericVector)
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	selectWeightedMixtureCombination = function(weights) {
		# copy parameters
		tmp_weights = self$.api$.toJava$RNumericVector(weights);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="selectWeightedMixtureCombination" , tmp_weights); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' withDefaultPrior: 
	#' This sets the selection strategy for prior estimate of the reproduction number to be the fixed R0 value provided to the CoriEstimator::new constructor. All estimates use the same prior
	#' and this is equivalent to the strategy implemented in EpiEstim (which has a default value of 5 for the mean and 5 for the SD of the R0 prior). This is an uninformed prior strategy.
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	withDefaultPrior = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="withDefaultPrior" ); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' withFixedPrior: 
	#' This sets the selection strategy for prior estimate of the reproduction number to be fixed value. All estimates use the same value as an uninformed prior, but enables us to compare the
	#' impact of different priors.
	#' @param mean - the mean of the fixed prior \(R_t\) - (java expects a double)
	#' @param sd - the sd  of the fixed prior \(R_t\) - (java expects a double)
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	withFixedPrior = function(mean, sd) {
		# copy parameters
		tmp_mean = self$.api$.toJava$double(mean);
		tmp_sd = self$.api$.toJava$double(sd);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="withFixedPrior" , tmp_mean, tmp_sd); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' withAdaptivePrior: 
	#' This sets the prior to be the posterior for the previous timestep, but with the SD of the previous posterior widened to allow the equivalent of a random walk. The widening factor defines how much 
	#' change we expect to see in each time step
	#' @param factor - must be above 1 (or else the estimate will become locked on a specific value) - (java expects a double)
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	withAdaptivePrior = function(factor) {
		# copy parameters
		tmp_factor = self$.api$.toJava$double(factor);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="withAdaptivePrior" , tmp_factor); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' collectResampledQuantiles: 
	#' This configures how the estimator combines multiple estimates of \(R_t\) using different infectivity profiles. In this case the estimator will 
	#' randomly sample from the selected posterior gamma distribution produced for each infectivity profile. These samples are combined and a mean, sd and empirical 
	#' quantiles calculated.
	#' @param sampleSize - the number of samples to draw for each posterior estimate of \(R_t\). This number will be multiplied by the number of infectivity profile estimates and the number time points, so should not be set too high or it will lead to memory consumption issues. This is the equivalent of the $n2$ parameter in EpiEstim - (java expects a int)
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	collectResampledQuantiles = function(sampleSize) {
		# copy parameters
		tmp_sampleSize = self$.api$.toJava$int(sampleSize);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="collectResampledQuantiles" , tmp_sampleSize); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' collectMixtureQuantiles: 
	#' This configures how the estimator combines multiple estimates of \(R_t\) using different infectivity profiles. In this case it calculates a mixture distribution 
	#' of all the posterior estimates, and combined values for mean, and standard deviation, of the mixture plus the quantiles using a brent solver.
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	collectMixtureQuantiles = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="collectMixtureQuantiles" ); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' collectMixtureApproximation: 
	#' This configures how the estimator combines multiple estimates of \(R_t\) using different infectivity profiles. In this case it calculates a mixture distribution 
	#' of all the posterior estimates, and then estimates a single gamma distribution with the same mean and SD as the mixture. This will only be a valid approximation
	#' if all the posterior estimates are close to each other, which will be the case if the infectivitiy profiles are fairly similar. It shoudl tend to produce estimates
	#' with less confidence. It is however the quickest method.
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	collectMixtureApproximation = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="collectMixtureApproximation" ); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' detailedOutput: 
	#' Configure the estimator to output full details for all infectivity profiles.
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	detailedOutput = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="detailedOutput" ); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' withInfectivityProfile: 
	#' Configure the estimator with an infectivity profile. At least one profile must be added
	#' @param infectivityProfile - A numeric vector of the daily discrete probability of a secondary infection event occurring given an infected individual. It is assumed that this vector starts 
	#' at time zero with a probability of zero. - (java expects a RNumericVector)
	#' @param replace -  replace the existing infectivity profile with this new one? if false then the profile is added to a list. - (java expects a boolean)
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	withInfectivityProfile = function(infectivityProfile, replace) {
		# copy parameters
		tmp_infectivityProfile = self$.api$.toJava$RNumericVector(infectivityProfile);
		tmp_replace = self$.api$.toJava$boolean(replace);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="withInfectivityProfile" , tmp_infectivityProfile, tmp_replace); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' withInfectivityProfileMatrix: 
	#' Configure the estimator with an infectivity profile by specifying it as a matrix. This will replace all previously set profiles.
	#' @param infectivityProfiles - A numeric array of the daily discrete probability of a secondary infection event occurring given an infected individual. It is assumed that this vector starts 
	#' at time zero with a probability of zero. - (java expects a RNumericArray)
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	withInfectivityProfileMatrix = function(infectivityProfiles) {
		# copy parameters
		tmp_infectivityProfiles = self$.api$.toJava$RNumericArray(infectivityProfiles);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="withInfectivityProfileMatrix" , tmp_infectivityProfiles); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' atStartOfTimeseries: 
	#' If the timeseries is at the start then we can safely impute zero values prior to the start of the timeseries. If the timeseries starts in the middle of the epidemic we must infer the 
	#' infections prior to the beginning of the time series if we are to prevent sudden jumps in the estimates over the initial part of the timeseries.
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	atStartOfTimeseries = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="atStartOfTimeseries" ); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' inMiddleOfTimeseries: 
	#' If the timeseries starts in the middle of the epidemic we must infer the 
	#' infections prior to the beginning of the time series if we are to prevent sudden jumps in the 
	#' estimates over the initial part of the timeseries. This is done using the supplied value of R0 to 
	#' infer a growth rate.
	#' @return R6 CoriEstimator object: 
	#' The estimator itself (a fluent method)
	inMiddleOfTimeseries = function() {
		# copy parameters
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="inMiddleOfTimeseries" ); 
		# is this a fluent method?
		# if(.jcall(self$.jobj, returnSig="Z", method="equals", .jcast(tmp_out))) {
		if(self$.jobj$equals(tmp_out)) {
			# return fluent method
			self$.api$printMessages()
			invisible(self)
		} else {
			# wrap return java object in R6 class  
			out = CoriEstimator$new(
				self$.api$.fromJava$CoriEstimator(tmp_out),
				self$.api
			);
			self$.api$printMessages()
			return(out);
		}
	},
	#' @description 
	#' estimateRt: 
	#' Estimates \(R_t\) for a one or more timeseries of infections in an epidemic, where the supplied dataframe is grouped
	#' @param incidence - a dataframe containing at least 2 columns (one containing a date, the other a numeric count of cases). The dataframe may be grouped, in which case grouping is preserved, and each group is treated as a seperate time seriesincidenceColName - the name of the incidence column - (java expects a RDataframe)
	#' @param dateColName - the name of the date column - (java expects a String)
	#' @param incidenceColName - the name of the incidence column - (java expects a String)
	#' @return RDataframe: 
	#' a dataframe, containing either a summary of the estimates of \(R_t\) with mean, sd, and quantiles for each day, or a full breakdown of the component \(R_t\) estimates.
	estimateRt = function(incidence, dateColName, incidenceColName) {
		# copy parameters
		tmp_incidence = self$.api$.toJava$RDataframe(incidence);
		tmp_dateColName = self$.api$.toJava$String(dateColName);
		tmp_incidenceColName = self$.api$.toJava$String(incidenceColName);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Luk/co/terminological/rjava/types/RDataframe;", method="estimateRt" , tmp_incidence, tmp_dateColName, tmp_incidenceColName); 
		# convert java object back to R
		out = self$.api$.fromJava$RDataframe(tmp_out);
		self$.api$printMessages()
		if(is.null(out)) return(invisible(out))
		return(out);
	},
	#' @description 
	#' estimateRtSingle: 
	#' Estimates \(R_t\) for a single timeseries of infections in an epidemic.
	#' @param incidence - a dataframe containing at least 2 columns (one containing a date, the other a numeric count of cases). The dataframe may be grouped, in which case grouping is preservedincidenceColName - the name of the incidence column - (java expects a RDataframe)
	#' @param dateColName - the name of the date column - (java expects a String)
	#' @param incidenceColName - the name of the incidence column - (java expects a String)
	#' @return RDataframe: 
	#' a dataframe, containing either a summary of the estimates of \(R_t\) with mean, sd, and quantiles for each day, or a full breakdown of the component \(R_t\) estimates.
	estimateRtSingle = function(incidence, dateColName, incidenceColName) {
		# copy parameters
		tmp_incidence = self$.api$.toJava$RDataframe(incidence);
		tmp_dateColName = self$.api$.toJava$String(dateColName);
		tmp_incidenceColName = self$.api$.toJava$String(incidenceColName);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Luk/co/terminological/rjava/types/RDataframe;", method="estimateRtSingle" , tmp_incidence, tmp_dateColName, tmp_incidenceColName); 
		# convert java object back to R
		out = self$.api$.fromJava$RDataframe(tmp_out);
		self$.api$printMessages()
		if(is.null(out)) return(invisible(out))
		return(out);
	},
	#' @description 
	#' estimateRtFromRates: 
	#' Estimates \(R_t\) for a one or more timeseries of infections in an epidemic, where the supplied dataframe is grouped
	#' @param rates - a dataframe containing at least 2 columns (one containing a date, the other a numeric poission rate of cases). The dataframe may be grouped, in which case grouping is preserved, and each group is treated as a seperate time series - (java expects a RDataframe)
	#' @param dateColName - the name of the date column - (java expects a String)
	#' @param rateColName - the name of the rate column - (java expects a String)
	#' @param samplesPerProfile - the number of times to bootstrap per infectivity profile - (java expects a int)
	#' @return RDataframe: 
	#' a dataframe, containing either a summary of the estimates of \(R_t\) with mean, sd, and quantiles for each day, or a full breakdown of the component \(R_t\) estimates.
	estimateRtFromRates = function(rates, dateColName, rateColName, samplesPerProfile) {
		# copy parameters
		tmp_rates = self$.api$.toJava$RDataframe(rates);
		tmp_dateColName = self$.api$.toJava$String(dateColName);
		tmp_rateColName = self$.api$.toJava$String(rateColName);
		tmp_samplesPerProfile = self$.api$.toJava$int(samplesPerProfile);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Luk/co/terminological/rjava/types/RDataframe;", method="estimateRtFromRates" , tmp_rates, tmp_dateColName, tmp_rateColName, tmp_samplesPerProfile); 
		# convert java object back to R
		out = self$.api$.fromJava$RDataframe(tmp_out);
		self$.api$printMessages()
		if(is.null(out)) return(invisible(out))
		return(out);
	},
	#' @description 
	#' estimateRtFromSingleRate: 
	#' Estimates \(R_t\) for a single timeseries of infections in an epidemic.
	#' @param rate - a dataframe containing at least 2 columns (one containing a date, the other a numeric estimate of possion rate of cases). The dataframe may be grouped, in which case grouping is preservedrateColName - the name of the estimated poisson rate - (java expects a RDataframe)
	#' @param dateColName - the name of the date column - (java expects a String)
	#' @param rateColName - the name of the estimated poisson rate - (java expects a String)
	#' @param samplesPerProfile - the number of times to bootstrap per infectivity profile - (java expects a int)
	#' @return RDataframe: 
	#' a dataframe, containing either a summary of the estimates of \(R_t\) with mean, sd, and quantiles for each day, or a full breakdown of the component \(R_t\) estimates.
	estimateRtFromSingleRate = function(rate, dateColName, rateColName, samplesPerProfile) {
		# copy parameters
		tmp_rate = self$.api$.toJava$RDataframe(rate);
		tmp_dateColName = self$.api$.toJava$String(dateColName);
		tmp_rateColName = self$.api$.toJava$String(rateColName);
		tmp_samplesPerProfile = self$.api$.toJava$int(samplesPerProfile);
		# execute method call
		tmp_out = .jcall(self$.jobj, returnSig = "Luk/co/terminological/rjava/types/RDataframe;", method="estimateRtFromSingleRate" , tmp_rate, tmp_dateColName, tmp_rateColName, tmp_samplesPerProfile); 
		# convert java object back to R
		out = self$.api$.fromJava$RDataframe(tmp_out);
		self$.api$printMessages()
		if(is.null(out)) return(invisible(out))
		return(out);
	},
	
	#' @description The output of toString() of this CoriEstimator
	print = function() {
		tmp_out = .jcall(self$.jobj, returnSig = "Ljava/lang/String;", method="toString");
		self$.api$printMessages()
		print(tmp_out)
		invisible(self)
	},
	
	#' @description The output of equals() of this CoriEstimator
	#' @param object The R6 instance to test for equality to this CoriEstimator  
	equals = function(object) {
		if (is.null(object$.jobj)) return(FALSE)
		return(self$.jobj$equals(object$.jobj))
	},
	
	#' @description Allow this object to be garbage collected.
	finalize = function() {
		self$.jobj = .jnull("org/github/terminological/jepidemic/estimate/CoriEstimator")
		self$.jobj = NULL
		.jgc(R.gc = FALSE)
	}
))
