---
title: "Cori method"
author: "Rob Challen"
date: '`r format(Sys.Date(), "%d-%m-%Y")`'
output: 
  pdf_document :
    fig_caption: yes
header-includes:
 \usepackage{float}
 \usepackage{mathtools}
 \floatplacement{figure}{H}    

knit: (function(inputFile, encoding,...) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "~/Dropbox/covid19/serial-interval/", output_file=paste0('cori-method-',Sys.Date(),'.pdf')) })
fig_width: 7
fig_height: 5
out.width: "100%"
bibliography: jepidemic.bib
csl: jepidemic.csl
vignette: >
  %\VignetteIndexEntry{Cori method}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

---




```{r, include = TRUE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  error = TRUE
)
```



# Testing java implementation
```{r eval=FALSE}
try(detach("package:jepidemic", unload = TRUE),silent = TRUE)
remove.packages("jepidemic")
# rm(list = ls()) may be required to clear old versions of the library code
# Restarting R maybe also required if there was a running java VM otherwise changes to the jars on the classpath are not picked up.
# install locally compiled R library:
devtools::install("~/Git/jepidemic/r-library/", upgrade = "never")
```

```{r}

library(EpiEstim)
data(Flu2009)

ggplot(Flu2009$incidence,aes(x=dates,y=I))+geom_bar(stat="identity")

rtPlot = function(out, ylim=c(0,5)) {
  ggplot(out %>% filter(!is.nan(Rt.Mean)), aes(x=Rt.StartDate, y=Rt.Mean, colour=as.factor(Rt.Window)))+
    geom_point(size=1) +
    geom_errorbarh(aes(x=Rt.EndDate, xmin=Rt.StartDate, xmax=Rt.EndDate), alpha=0.3) +
    geom_errorbar(aes(y=Rt.Quantile.0.5, ymin = Rt.Quantile.0.025, ymax = Rt.Quantile.0.975), alpha=0.3)+
    facet_wrap(vars(as.factor(Rt.Window)))+guides(colour="none")+coord_cartesian(ylim=ylim)
}

rtPanel = function(out, ylim=c(0,5)) {
  ggplot(out %>% filter(!is.nan(Rt.Mean)), aes(x=Rt.StartDate, y=Rt.Mean, colour=as.factor(Rt.Window)))+
    geom_point(size=1) +
    geom_errorbarh(aes(x=Rt.EndDate, xmin=Rt.StartDate, xmax=Rt.EndDate), alpha=0.3) +
    geom_errorbar(aes(y=Rt.Quantile.0.5, ymin = Rt.Quantile.0.025, ymax = Rt.Quantile.0.975), alpha=0.3)+
    guides(colour="none")+coord_cartesian(ylim=ylim)
}
```

## Reference implementation

* Noise with smaller windows
* Particularly when smaller numbers at end of time series
* Windows > 4 lose some features when numbers larger in early part of time series
* No optimal.

```{r}
epiest = bind_rows(lapply(1:14, function(window) {
  tau = window-1
  tmp = EpiEstim::estimate_R(Flu2009$incidence, 
                             config = make_config(method = "non_parametric_si",
                                                  si_distr = Flu2009$si_distr, 
                                                  mean_prior=5, std_prior=5,
                                                  t_start=2:(32-tau),t_end=(2+tau):32))
  return(tmp$R %>% mutate(Rt.StartDate = tmp$date[t_start],
                          Rt.EndDate = tmp$date[t_end],
                          Rt.Mean = `Mean(R)`, 
                          Rt.Quantile.0.5 = `Median(R)`, 
                          Rt.Quantile.0.025 = `Quantile.0.025(R)`, 
                          Rt.Quantile.0.975 = `Quantile.0.975(R)`,
                          Rt.Window = window
  ))
}))
p1 = incidencePlot(Flu2009$incidence %>% mutate(date = dates, value = I, subgroup="none"))
p2 = rtPlot(epiest,ylim = c(0,5))+facet_wrap(vars(Rt.Window),ncol=7)

p1+p2+plot_annotation(tag_levels = "A")+plot_layout(ncol=1)
```


```{r}
# Ensure equivalence
J = jepidemic::JavaApi$new()
estim = J$CoriEstimator$new(r0Mean = 5,r0SD = 4,maxWindow = 14)
estim$withInfectivityProfile(infectivityProfile = Flu2009$si_distr)
estim$detailedOutput()
estim$withDefaultPrior()
estim$atStartOfTimeseries()


jepidem = estim$estimateRtSingle(incidence = Flu2009$incidence,dateColName = "dates", incidenceColName = "I")

comp = epiest %>% filter(is.finite(Rt.Mean)) %>% select(Rt.StartDate,Rt.EndDate,Rt.Window,Rt.Mean) %>% #,Rt.Quantile.0.5,Rt.Quantile.0.025,Rt.Quantile.0.975) %>%
  inner_join(
    jepidem %>% filter(is.finite(Rt.Mean)) %>% select(Rt.StartDate,Rt.EndDate,Rt.Window,Rt.Mean), #,Rt.Quantile.0.5,Rt.Quantile.0.025,Rt.Quantile.0.975),
    by=c("Rt.StartDate","Rt.EndDate","Rt.Window"), suffix=c(".epiest",".jepidem")
)

mismatches = comp %>% mutate(matches = abs(Rt.Mean.epiest - Rt.Mean.jepidem)<0.000000000001) %>% filter(isFALSE(matches));

if (mismatches %>% nrow() != 0) {
  mismatches
  stop("mismatch between jepidemic and epiestim")
}
# rtPlot(out)

# https://raw.githubusercontent.com/epiforecasts/EpiNow2/master/inst/dev/figs/gp_nuts.png
# https://raw.githubusercontent.com/epiforecasts/EpiNow2/master/inst/dev/figs/backcalc_nuts.png
# https://github.com/epiforecasts/EpiNow2/blob/master/inst/dev/recover-synthetic.R
# https://github.com/epiforecasts/EpiSoon - simulation
# https://github.com/epiforecasts/scoringutils
```

```{r}
klGammaVsGamma = function(mean1, sd1, mean2, sd2) {
  if (sd1>mean1 | sd2>mean2) stop("sd must be smaller than mean")
  range = seq(0,10,length=200)
  g1 = dgamma(range, shape=mean1^2/sd1^2,rate = mean1/sd1^2)
  g2 = dgamma(range, shape=mean2^2/sd2^2,rate = mean2/sd2^2)
  kl = flexmix::KLdiv(cbind(g1=g1,g2=g2))[1,2]
  # A matrix of KL divergences where the rows correspond to using the respective distribution as  in the formula above.
  return(kl)
}

klGammaVsUnif = function(value1, precision1, mean2, sd2) {
  if (sd2>mean2) stop("sd must be smaller than mean")
  range = seq(0,10,length=200)
  g1 = dunif(range, min = value1-precision1,max = value1+precision1)
  g2 = dgamma(range, shape=mean2^2/sd2^2,rate = mean2/sd2^2)
  kl = flexmix::KLdiv(cbind(g1=g1,g2=g2))[1,2]
  # A matrix of KL divergences where the rows correspond to using the respective distribution as  in the formula above.
  return(kl)
}


klGammaVsGamma(mean1=2,sd1=1.5,mean2=2.3,sd2=2.1)
klGammaVsUnif(value1=2,precision1=0.0001,mean2=2,sd2=0.002)

```

```{r}

estim$withAdaptivePrior(factor = 1.3)
estim$detailedOutput()
out2 = estim$estimateRtSingle(incidence = Flu2009$incidence,dateColName = "dates", incidenceColName = "I")
rtPlot(out2)
```


```{r}

estim$withFixedPrior(mean = 1,sd = 5)
out3 = estim$estimateRtSingle(incidence = Flu2009$incidence,dateColName = "dates", incidenceColName = "I")
rtPlot(out3)
```

```{r}

#install.packages("projections")


Rt = tibble::tibble(
  date = as.Date(as.Date("2020-01-01"):(as.Date("2020-01-01")+99),"1970-01-01"),
  time_change = 1:100
) %>% mutate(
  R = case_when(
    time_change <= 20 ~ 1,
    time_change <= 40 ~ 1.1,
    time_change <= 60 ~ 0.6,
    time_change <= 80 ~ 1,
    TRUE ~ 1.5,
    )
)



seed = incidence::incidence(dates = as.Date(unlist(lapply(as.Date("2019-12-15"):as.Date("2019-12-31"),function(x) rep(x,runif(1,95,105)))),"1970-01-01"))
proj_3 <- projections::project(x = seed, R = c(Rt$R,1), n_sim=1,si = Flu2009$si_distr, n_days = 200, time_change = Rt$time_change)
plot(proj_3)
tmp = as.data.frame(seed) %>% rename(date = dates, incidence=counts) %>% bind_rows(as.data.frame(proj_3,long=TRUE) %>% group_by(date) %>% summarise(incidence = mean(incidence)))
Rt = Rt %>% inner_join(tmp, by="date")
```

```{r}

i <- incidence::incidence(dates = "2020-01-01")

# Rt_vec = c(
#   rep(4,20),
#   rep(2.1,20),
#   rep(0.5,20),
#   rep(1.2,20))

seed = incidence::incidence(dates = as.Date(unlist(lapply(as.Date("2019-12-15"):as.Date("2019-12-31"),function(x) rep(x,runif(1,95,105)))),"1970-01-01"))

# Rt_vec = spline(c(0,20,40,60,80,100), c(2,1,1.1,0.6,1,1.5), n=101)$y

Rt_vec = c(
  spline(c(0,20,40,50), c(1.25,1,0.75,1.5), n=51)$y,
  spline(c(51,60,80,100), c(3,2,0.6,1), n=50)$y
)

plot(Rt_vec)

proj_4 <- projections::project(seed,
  R = Rt_vec,
  si = Flu2009$si_distr,
  n_days = length(Rt_vec),
  time_change = 1:(length(Rt_vec)-1),
  n_sim = 100)
plot(proj_4)

Rt = proj_4 %>% as.data.frame(row.names = TRUE) %>%
  mutate(R = Rt_vec) %>%
  pivot_longer(cols = c(-dates,-R),values_to="incidence",names_to="sim",names_pattern="([0-9]+)") %>%
  mutate(sim = as.integer(sim), incidence=as.numeric(incidence)) %>% 
  rename(date = dates)

```


```{r}
estim$withDefaultPrior()
out4 = estim$estimateRt(Rt %>% group_by(sim),dateColName = "date",incidenceColName = "incidence")
out4a = out4 %>% group_by(Rt.ProfileId,date,Rt.Window,Rt.StartDate,Rt.EndDate) %>% summarise(across(c(incidence,starts_with("Rt")), ~mean(.x,na.rm = TRUE)))
rtPlot(out4a,ylim=c(0.5,4))+geom_line(data=Rt,aes(x=date,y=R),colour="black",alpha=0.5)
```


```{r}
J = jepidemic::JavaApi$new()
estim2 = J$CoriEstimator$new(r0Mean = 5,r0SD = 4,maxWindow = 14)
estim2$withInfectivityProfile(infectivityProfile = Flu2009$si_distr)
estim2$inMiddleOfTimeseries()
estim2$withAdaptivePrior(10)
estim2$selectAdaptiveWindow(incidenceSum = 200,minWindow = 3)
estim2$collectMixtureQuantiles()

out5 = estim2$estimateRt(Rt %>% group_by(sim),dateColName = "date",incidenceColName = "incidence")
out6 = out5 %>% group_by(Rt.StartDate) %>% summarise(across(c(incidence,starts_with("Rt")), ~mean(.x,na.rm = TRUE)))
rtPanel(out5,ylim=c(0.5,4))+geom_line(data=Rt,aes(x=date,y=R),colour="black",alpha=0.5)

```


```{r}

testData = tibble(time = 1:200) %>% mutate(growth_rate = case_when(
  time < 60 ~ 0.05,
  time < 80 ~ -0.025,
  time < 140 ~ -0.025+0.045/40*(time-80),
  time < 180 ~ -0.05,
  TRUE ~ 0.03
), value = growth_rate ) %>% 
  mutate(type = "incidence", lambda_t = cumsum(growth_rate), date = as.Date("2020-01-01")+time) %>%
  group_by_all() %>%
  summarise(tibble(subgroup = 1:10,value=rpois(10,100*exp(lambda_t)))) %>%
  ungroup()

testTs = testData %>% mutate(statistic = "case",type = "incidence", code="XYZ", name="Test",codeType = "TEST",source="TEST",gender=NA_character_,ageCat=NA_character_)

ggplot(testTs,aes(x=date,y=value,group=subgroup))+geom_line(alpha=0.2)


discGRToR = function(growth_rate, y = Flu2009$si_distr ) {
  a = seq(0.5,length.out = length(y),by = 1)
  p = y/(a - lag(a,default=0))
  #browser()
  # out = growth_rate %>% slider::slide_dbl( function(r) {
  #   # browser()
  #   r = rev(r)
  #   r0 = r[1]
  #   r = r[-1]
  #   ((r0*0.5+sum(r))/max(a))/sum(p*(exp(-lag(r,default=r0)*lag(a,default=0))-exp(-r*a)))
  # }, .before=length(y),.complete = TRUE)
  # 
  out = sapply(growth_rate, function(r) {
    # browser()
    r/sum(p*(exp(-r*lag(a,default=0))-exp(-r*a)))
  })
  
  return(out)
  
  # R = pmap(list(r,d$a,d$y,d$p), function(r,a,y,p) {
  #   # tmp = r/sum(y*(exp(-r*lag(a,default=0))-exp(-r*a))/(a - lag(a,default=0)))
  #   tmp = r/sum(p*(exp(-r*lag(a,default=0))-exp(-r*a)))
  #   # if(!is.finite(tmp)) browser()
  #   return(tmp)
  # })
  # # browser()
  # return(unlist(R))
}

testTs = testTs %>% group_by(subgroup) %>% mutate(Rt = discGRToR(growth_rate))

estim2$withAdaptivePrior(10)
out7 = estim2$estimateRt(testTs %>% group_by(subgroup) %>% mutate(value = as.numeric(value)),dateColName = "date",incidenceColName = "value")

rtPanel(out7 %>% filter(subgroup==1),ylim=c(0.5,2))+geom_line(data=testTs,aes(x=date,y=Rt),colour="black",alpha=0.5)

```