# Generated by r6-generator-maven-plugin: do not edit by hand
# This is the main entry point of the jepidemic generated R library.
#
# Java Epidemic
# Version: 0.03
# Generated: 2021-06-19T00:37:06.848829
# Contact: rc538@exeter.ac.uk
JavaApi = R6::R6Class("JavaApi", public=list( 
	#### fields ----
	.log = NULL,
	.fromJava = NULL,
	.toJava = NULL,
	.reg = list(),
	InfectivityProfile = NULL,
	CoriEstimator = NULL,
  
  	changeLogLevel = function(logLevel) {
  		.jcall("uk/co/terminological/rjava/LogController", returnSig = "V", method = "changeLogLevel" , logLevel)
    },
	
	reconfigureLog = function(log4jproperties) {
  		.jcall("uk/co/terminological/rjava/LogController", returnSig = "V", method = "reconfigureLog" , log4jproperties)
    },
	
	printMessages = function() {
		cat(.jcall("uk/co/terminological/rjava/LogController", returnSig = "Ljava/lang/String;", method = "getSystemMessages"))
		invisible(NULL)
	},
	
	
 	#### constructor ----
 	initialize = function(logLevel = "INFO") {
 		if (!is.null(JavaApi$singleton)) stop("Startup the java api with JavaApi$get() rather than using this constructor directly")
 	
		if (!.jniInitialized) 
	        .jinit(parameters=getOption("java.parameters"),silent = TRUE, force.init = FALSE)
		
		# add in all the jars that come with the library
	    classes <- system.file("java", package = "jepidemic")
	    if (nchar(classes)) {
	        .jaddClassPath(classes)
	        jars <- grep(".*\\.jar", list.files(classes, full.names = TRUE), TRUE, value = TRUE)
	        message(paste0("Adding to classpath: ",jars,collapse='\n'))
	        .jaddClassPath(jars)
	    }
 	
 		.jcall("uk/co/terminological/rjava/LogController", returnSig = "V", method = "setupRConsole")
 		.jcall("uk/co/terminological/rjava/LogController", returnSig = "V", method = "configureLog" , logLevel)
    	self$.log = .jcall("org/slf4j/LoggerFactory", returnSig = "Lorg/slf4j/Logger;", method = "getLogger", "jepidemic");
    	.jcall(self$.log,returnSig = "V",method = "info","Initialised jepidemic");
		.jcall(self$.log,returnSig = "V",method = "debug","Version: 0.03");
		.jcall(self$.log,returnSig = "V",method = "debug","Generated: 2021-06-19T00:37:06.849064");
		.jcall(self$.log,returnSig = "V",method = "debug","Contact: rc538@exeter.ac.uk");
		self$printMessages()
		# initialise type conversion functions
		
		self$.toJava = list(
			RNumericArray=function(rObj) {
				if (is.null(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RNumericArray'))
				if (!is.numeric(rObj)) stop('expected a numeric')
				if (!is.array(rObj)) stop('expected an array')
				tmpVec = as.vector(as.numeric(rObj))
				tmpDim = dim(rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RNumericArray',rJava::.jarray(tmpVec),rJava::.jarray(tmpDim)))
			},
			RDateVector=function(rObj) {
				if (is.null(rObj)) return(rJava::.new('uk/co/terminological/rjava/types/RDateVector'))
				if (any(na.omit(rObj)<'0001-01-01')) message('dates smaller than 0001-01-01 will be converted to NA')
				tmp = as.character(rObj,format='%C%y-%m-%d')
				return(rJava::.jnew('uk/co/terminological/rjava/types/RDateVector',rJava::.jarray(tmp)))
			},
			RDate=function(rObj) {
				if (is.na(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RDate'))
				if (length(rObj) > 1) stop('input too long')
			   if (rObj<'0001-01-01') message('dates smaller than 0001-01-01 will be converted to NA')
				tmp = as.character(rObj,format='%C%y-%m-%d')[[1]]
				return(rJava::.jnew('uk/co/terminological/rjava/types/RDate',tmp))
			},
			RCharacterVector=function(rObj) {
				if (is.null(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RCharacterVector'))
				if (!is.character(rObj)) stop('expected a vector of characters')
				tmp = as.character(rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RCharacterVector',rJava::.jarray(tmp)))
			},
			RNumeric=function(rObj) {
				if (length(rObj) > 1) stop('input too long')
				if (!is.numeric(rObj)) stop('expected a numeric')
				tmp = as.numeric(rObj)[[1]]
				return(rJava::.jnew('uk/co/terminological/rjava/types/RNumeric',tmp))
			},
			RFactor=function(rObj) {
				if (is.na(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RFactor'))
				if (length(rObj) > 1) stop('input too long')
				tmp = as.integer(rObj)[[1]]
				tmpLabel = levels(rObj)[[tmp]]
				return(rJava::.jnew('uk/co/terminological/rjava/types/RFactor',tmp, tmpLabel))
			},
			RLogical=function(rObj) {
				if (is.na(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RLogical'))
				if (length(rObj) > 1) stop('input too long')
				if (!is.logical(rObj)) stop('expected a logical')
				tmp = as.integer(rObj)[[1]]
				return(rJava::.jnew('uk/co/terminological/rjava/types/RLogical',tmp))
			},
			RNull=function(rObj) {
				if (!is.null(rObj)) stop('input expected to be NULL')
				return(rJava::.jnew('uk/co/terminological/rjava/types/RNull'))
			},
			RLogicalVector=function(rObj) {
				if (is.null(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RLogicalVector'))
				if (!is.logical(rObj)) stop('expected a vector of logicals')
				tmp = as.integer(rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RLogicalVector',rJava::.jarray(tmp)))
			},
			RCharacter=function(rObj) {
				if (is.na(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RCharacter'))
				tmp = as.character(rObj)[[1]]
				return(rJava::.jnew('uk/co/terminological/rjava/types/RCharacter',tmp))
			},
			String=function(rObj) return(as.character(rObj)),
			CoriEstimator=function(rObj) return(rObj$.jobj),
			void=function(rObj) stop('no input expected'),
			double=function(rObj) {
			    if (is.na(rObj)) stop('cant use NA as input to java double')
			    if (length(rObj) > 1) stop('input too long')
			    if (!is.numeric(rObj)) stop('not an double')
			    return(as.numeric(rObj[[1]]))
			},
			RList=function(rObj) {
			   if (!is.list(rObj)) stop ('expecting a list ')
			   if (!is.null(names(rObj))) warning('not expecting list to be named')
				jout = rJava::.jnew('uk/co/terminological/rjava/types/RList')
				lapply(rObj, function(x) {
					if (is.null(x)) tmp = self$.toJava$RNull(x)
					else if (is.data.frame(x)) tmp = self$.toJava$RDataframe(x)
					else if (is.list(x) & !is.null(names(x))) tmp = self$.toJava$RNamedList(x)
					else if (is.list(x)) tmp = self$.toJava$RList(x)
					else if (is.array(x) & is.numeric(x)) tmp = self$.toJava$RNumericArray(x)
					else if (length(x) == 1 & is.character(x)) tmp = self$.toJava$RCharacter(x)
					else if (length(x) == 1 & is.integer(x)) tmp = self$.toJava$RInteger(x)
					else if (length(x) == 1 & is.factor(x)) tmp = self$.toJava$RFactor(x)
					else if (length(x) == 1 & is.logical(x)) tmp = self$.toJava$RLogical(x)
					else if (length(x) == 1 & is.numeric(x)) tmp = self$.toJava$RNumeric(x)
					else if (length(x) == 1 & inherits(x,c('Date','POSIXt'))) tmp = self$.toJava$RDate(x)
					else if (is.character(x)) tmp = self$.toJava$RCharacterVector(x)
					else if (is.integer(x)) tmp = self$.toJava$RIntegerVector(x)
					else if (is.factor(x)) tmp = self$.toJava$RFactorVector(x)
					else if (is.logical(x)) tmp = self$.toJava$RLogicalVector(x)
					else if (is.numeric(x)) tmp = self$.toJava$RNumericVector(x)
					else if (inherits(x,c('Date','POSIXt'))) tmp = self$.toJava$RDateVector(x)
					else stop ('unrecognised type: ',class(x),' with value ',x)
					rJava::.jcall(jout,returnSig='Z',method='add',rJava::.jcast(tmp, new.class='uk/co/terminological/rjava/types/RObject'))
				})
				return(jout)
			},
			RNumericVector=function(rObj) {
				if (is.null(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RNumericVector'))
				if (!is.numeric(rObj)) stop('expected a numeric')
				tmp = as.numeric(rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RNumericVector',rJava::.jarray(tmp)))
			},
			int=function(rObj) {
			    if (is.na(rObj)) stop('cant use NA as input to java int')
			    if (length(rObj) > 1) stop('input too long')
			    if (as.integer(rObj)[[1]]!=rObj[[1]]) stop('not an integer')
			    return(as.integer(rObj[[1]]))
			},
			boolean=function(rObj) {
			    if (is.na(rObj)) stop('cant use NA as input to java boolean')
			    if (length(rObj) > 1) stop('input too long')
			    if (!is.logical(rObj)) stop('not a logical')
			    return(as.logical(rObj[[1]]))
			},
			RBoundDataframe=function(rObj) {
				jout = rJava::.jnew('uk/co/terminological/rjava/types/RDataframe')
				lapply(colnames(rObj), function(x) {
					rcol = rObj[[x]]
					if(is.character(rcol)) jvec = self$.toJava$RCharacterVector(rcol)
					else if(is.integer(rcol)) jvec = self$.toJava$RIntegerVector(rcol)
					else if(is.factor(rcol)) jvec = self$.toJava$RFactorVector(rcol)
					else if(is.logical(rcol)) jvec = self$.toJava$RLogicalVector(rcol)
					else if(is.numeric(rcol)) jvec = self$.toJava$RNumericVector(rcol)
					else if(inherits(rcol,c('Date','POSIXt'))) jvec = self$.toJava$RDateVector(rcol)
					else stop('unsupported data type in column: ',x)
					rJava::.jcall(jout,returnSig='V',method='addCol',x,rJava::.jcast(jvec,new.class='uk/co/terminological/rjava/types/RVector'))
				})
				rJava::.jcall(jout,returnSig='Luk/co/terminological/rjava/types/RDataframe;',method='groupBy',rJava::.jarray(dplyr::group_vars(rObj)))
				return(jout)
			},
			RInteger=function(rObj) {
				if (is.na(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RInteger'))
				if (length(rObj) > 1) stop('input too long')
				tmp = as.integer(rObj)[[1]]
				if (rObj[[1]]!=tmp) stop('cannot cast to integer: ',rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RInteger',tmp))
			},
			RDataframe=function(rObj) {
				jout = rJava::.jnew('uk/co/terminological/rjava/types/RDataframe')
				lapply(colnames(rObj), function(x) {
					rcol = rObj[[x]]
					if(is.character(rcol)) jvec = self$.toJava$RCharacterVector(rcol)
					else if(is.integer(rcol)) jvec = self$.toJava$RIntegerVector(rcol)
					else if(is.factor(rcol)) jvec = self$.toJava$RFactorVector(rcol)
					else if(is.logical(rcol)) jvec = self$.toJava$RLogicalVector(rcol)
					else if(is.numeric(rcol)) jvec = self$.toJava$RNumericVector(rcol)
					else if(inherits(rcol,c('Date','POSIXt'))) jvec = self$.toJava$RDateVector(rcol)
					else stop('unsupported data type in column: ',x)
					rJava::.jcall(jout,returnSig='V',method='addCol',x,rJava::.jcast(jvec,new.class='uk/co/terminological/rjava/types/RVector'))
				})
				rJava::.jcall(jout,returnSig='Luk/co/terminological/rjava/types/RDataframe;',method='groupBy',rJava::.jarray(dplyr::group_vars(rObj)))
				return(jout)
			},
			InfectivityProfile=function(rObj) return(rObj$.jobj),
			RFactorVector=function(rObj) {
				if (is.null(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RFactorVector'))
				if (!is.factor(rObj)) stop('expected a vector of factors')
				tmp = as.integer(rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RFactorVector', rJava::.jarray(tmp), rJava::.jarray(levels(rObj))))
			},
			RIntegerVector=function(rObj) {
				if (is.null(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RIntegerVector'))
				tmp = as.integer(rObj)
				if (any(rObj!=tmp,na.rm=TRUE)) stop('cannot coerce to integer: ',rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RIntegerVector',rJava::.jarray(tmp)))
			},
			RNamedList=function(rObj) {
				if (!is.list(rObj) | is.null(names(rObj))) stop ('expecting a named list')
				jout = rJava::.jnew('uk/co/terminological/rjava/types/RNamedList')
				lapply(names(rObj), function(name) {
					x = rObj[[name]]
					if (is.null(x)) tmp = self$.toJava$RNull(x)
					else if (is.data.frame(x)) tmp = self$.toJava$RDataframe(x)
					else if (is.list(x) & !is.null(names(x))) tmp = self$.toJava$RNamedList(x)
					else if (is.list(x)) tmp = self$.toJava$RList(x)
					else if (is.array(x) & is.numeric(x)) tmp = self$.toJava$RNumericArray(x)
					else if (length(x) == 1 & is.character(x)) tmp = self$.toJava$RCharacter(x)
					else if (length(x) == 1 & is.integer(x)) tmp = self$.toJava$RInteger(x)
					else if (length(x) == 1 & is.factor(x)) tmp = self$.toJava$RFactor(x)
					else if (length(x) == 1 & is.logical(x)) tmp = self$.toJava$RLogical(x)
					else if (length(x) == 1 & is.numeric(x)) tmp = self$.toJava$RNumeric(x)
					else if (length(x) == 1 & inherits(x,c('Date','POSIXt'))) tmp = self$.toJava$RDate(x)
					else if (is.character(x)) tmp = self$.toJava$RCharacterVector(x)
					else if (is.integer(x)) tmp = self$.toJava$RIntegerVector(x)
					else if (is.factor(x)) tmp = self$.toJava$RFactorVector(x)
					else if (is.logical(x)) tmp = self$.toJava$RLogicalVector(x)
					else if (is.numeric(x)) tmp = self$.toJava$RNumericVector(x)
					else if (inherits(x,c('Date','POSIXt'))) tmp = self$.toJava$RDateVector(x)
					else stop ('unrecognised type: ',class(x),' with value ',x)
					rJava::.jcall(jout,returnSig='Luk/co/terminological/rjava/types/RObject;',method='put',name,rJava::.jcast(tmp, new.class='uk/co/terminological/rjava/types/RObject'))
				})
				return(jout)
			}		)
		
		self$.fromJava = list(
			RNumericArray=function(jObj) {
				tmpVec = as.numeric(rJava::.jcall(jObj,returnSig='[D',method='rPrimitive'))
				tmpDim = as.integer(rJava::.jcall(jObj,returnSig='[I',method='rDim'))
			   if (length(tmpDim)==2) return(matrix(tmpVec,tmpDim))
				return(array(tmpVec,tmpDim))
			},
			RDateVector=function(jObj) as.Date(rJava::.jcall(jObj,returnSig='[Ljava/lang/String;',method='rPrimitive'),'%Y-%m-%d'),
			RDate=function(jObj) as.Date(rJava::.jcall(jObj,returnSig='Ljava/lang/String;',method='rPrimitive'),'%Y-%m-%d'),
			RCharacterVector=function(jObj) as.character(rJava::.jcall(jObj,returnSig='[Ljava/lang/String;',method='rPrimitive')),
			RNumeric=function(jObj) as.numeric(rJava::.jcall(jObj,returnSig='D',method='rPrimitive')),
			RFactor=function(jObj) as.character(rJava::.jcall(jObj,returnSig='Ljava/lang/String;',method='rLabel')),
			RLogical=function(jObj) as.logical(rJava::.jcall(jObj,returnSig='I',method='rPrimitive')),
			RNull=function(jObj) return(NULL),
			RLogicalVector=function(jObj) as.logical(rJava::.jcall(jObj,returnSig='[I',method='rPrimitive')),
			RCharacter=function(jObj) as.character(rJava::.jcall(jObj,returnSig='Ljava/lang/String;',method='rPrimitive')),
			String=function(jObj) return(as.character(jObj)),
			CoriEstimator=function(jObj) return(jObj),
			void=function(jObj) invisible(NULL),
			double=function(jObj) return(as.numeric(jObj)),
			RList=function(jObj) {
				tmp = eval(parse(text=rJava::.jcall(jObj,'rCode', returnSig='Ljava/lang/String;')))
				return(tmp)
			},
			RNumericVector=function(jObj) as.numeric(rJava::.jcall(jObj,returnSig='[D',method='rPrimitive')),
			int=function(jObj) return(as.integer(jObj)),
			boolean=function(jObj) return(as.logical(jObj)),
			RBoundDataframe=function(jObj) {
				convDf = eval(parse(text=rJava::.jcall(jObj,'rConversion', returnSig='Ljava/lang/String;')))
				groups = rJava::.jcall(jObj,returnSig='[Ljava/lang/String;',method='getGroups')
				return(dplyr::group_by(convDf(jObj),!!!sapply(groups,as.symbol)))
			},
			RInteger=function(jObj) as.integer(rJava::.jcall(jObj,returnSig='I',method='rPrimitive')),
			RDataframe=function(jObj) {
				convDf = eval(parse(text=rJava::.jcall(jObj,'rConversion', returnSig='Ljava/lang/String;')))
				groups = rJava::.jcall(jObj,returnSig='[Ljava/lang/String;',method='getGroups')
				return(dplyr::group_by(convDf(jObj),!!!sapply(groups,as.symbol)))
			},
			InfectivityProfile=function(jObj) return(jObj),
			RFactorVector=function(jObj) ordered(
				x = rJava::.jcall(jObj,returnSig='[I',method='rValues'),
				labels = rJava::.jcall(jObj,returnSig='[Ljava/lang/String;',method='rLevels')
			),
			RIntegerVector=function(jObj) as.integer(rJava::.jcall(jObj,returnSig='[I',method='rPrimitive')),
			RNamedList=function(jObj) {
				tmp = eval(parse(text=rJava::.jcall(jObj,'rCode', returnSig='Ljava/lang/String;')))
				return(tmp)
			}		)
	
		# initialise java class constructors and static method definitions
		
		self$InfectivityProfile = list(
			new = function(discretePdf, id) {
				# constructor
				# convert parameters to java
				tmp_discretePdf = self$.toJava$RNumericVector(discretePdf);
				tmp_id = self$.toJava$int(id);
				# invoke constructor method
				tmp_out = .jnew("org/github/terminological/jepidemic/InfectivityProfile" , tmp_discretePdf, tmp_id); 
				# convert result back to R (should be a identity conversion)
				tmp_r6 = InfectivityProfile$new(
					self$.fromJava$InfectivityProfile(tmp_out),
					self
				);
				self$printMessages()
				return(tmp_r6)
			}
	)
		self$CoriEstimator = list(
			new = function(r0Mean, r0SD, maxWindow) {
				# constructor
				# convert parameters to java
				tmp_r0Mean = self$.toJava$double(r0Mean);
				tmp_r0SD = self$.toJava$double(r0SD);
				tmp_maxWindow = self$.toJava$int(maxWindow);
				# invoke constructor method
				tmp_out = .jnew("org/github/terminological/jepidemic/estimate/CoriEstimator" , tmp_r0Mean, tmp_r0SD, tmp_maxWindow); 
				# convert result back to R (should be a identity conversion)
				tmp_r6 = CoriEstimator$new(
					self$.fromJava$CoriEstimator(tmp_out),
					self
				);
				self$printMessages()
				return(tmp_r6)
			},
			defaultEpiEstim = function(infectivityProfile, meanR0, sdR0, window) {
				# copy parameters
				tmp_infectivityProfile = self$.toJava$RNumericVector(infectivityProfile);
				tmp_meanR0 = self$.toJava$double(meanR0);
				tmp_sdR0 = self$.toJava$double(sdR0);
				tmp_window = self$.toJava$int(window);
				#execute static call
				tmp_out = .jcall("org/github/terminological/jepidemic/estimate/CoriEstimator", returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="defaultEpiEstim" , tmp_infectivityProfile, tmp_meanR0, tmp_sdR0, tmp_window); 
				# wrap return java object in R6 class 
				out = CoriEstimator$new(
					self$.fromJava$CoriEstimator(tmp_out),
					self
				);
				self$printMessages()
				return(out)
			},
			defaultUncertainEpiEstim = function(infectivityProfiles, meanR0, sdR0, window, n2) {
				# copy parameters
				tmp_infectivityProfiles = self$.toJava$RNumericArray(infectivityProfiles);
				tmp_meanR0 = self$.toJava$double(meanR0);
				tmp_sdR0 = self$.toJava$double(sdR0);
				tmp_window = self$.toJava$int(window);
				tmp_n2 = self$.toJava$int(n2);
				#execute static call
				tmp_out = .jcall("org/github/terminological/jepidemic/estimate/CoriEstimator", returnSig = "Lorg/github/terminological/jepidemic/estimate/CoriEstimator;", method="defaultUncertainEpiEstim" , tmp_infectivityProfiles, tmp_meanR0, tmp_sdR0, tmp_window, tmp_n2); 
				# wrap return java object in R6 class 
				out = CoriEstimator$new(
					self$.fromJava$CoriEstimator(tmp_out),
					self
				);
				self$printMessages()
				return(out)
			}	)
	}
))

JavaApi$singleton = NULL

JavaApi$get = function(logLevel = "INFO") {
	if (is.null(JavaApi$singleton)) {
		JavaApi$singleton = JavaApi$new(logLevel)
	}
	return(JavaApi$singleton)
}

